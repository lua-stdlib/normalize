before:
  this_module   = "std.normalize"

  M = require (this_module)
  M.version = nil               -- previous specs may have autoloaded it


specify std.normalize:
- context when required:
  - it returns a functor:
      expect (type (getmetatable (M).__call)).to_be "function"
  - it does not touch the global table:
      expect (show_apis {added_to="_G", by=this_module}).
        to_equal {}

- context when lazy loading:
  - it has no unexpected submodules on initial load:
      expected = {package = 1}
      for k, v in pairs (M) do
        if not expected[k] then
          expect (type (v)).not_to_be "table"
        end
      end
  - it loads submodules on demand:
      lazy = M.version
      expect (lazy).to_be (require "std.normalize.version")

- context when called:
  - before:
      MAGIC = {"MAGIC"}
      f = M

  - it merges table argument fields:
      expect (f {myfield = 1}).to_contain.a_permutation_of {
        "myfield",
        "argerror", "getfenv", "getmetamethod", "ipairs", "len", "load",
        "opairs", "pack", "package", "pairs", "setfenv", "str",
        "unpack", "xpcall",
      }
  - it merges nested table fields:
      expect (f {package = {myfield = 1}}.package).
        to_contain.a_permutation_of {
          "myfield",
          "dirsep", "execdir", "igmark", "pathmark", "pathsep",
        }
  - it supports overriding fields:
      expect (f {len = MAGIC}.str).to_be (f.str)
      expect (f {len = MAGIC}.len).to_be (MAGIC)
  - it supports overriding nested table fields:
      expect (f {package = {execdir = MAGIC}}.package.dirsep).
        to_be (f.package.dirsep)
      expect (f {package = {execdir = MAGIC}}.package.execdir).
        to_be (MAGIC)


- describe argerror:
  - before: |
      preamble = [[
        argerror = require "std.normalize".argerror
        badfunc = function (n)
          argerror ("badfunc", 1, "you are an idiot", n and n > 0 and n + 1 or 0)
        end
        caller = function (n)
          (function () return (badfunc (n)) end)() -- 7 with _DEBUG line prepended --
        end
      ]]

      f = M.argerror

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
         expect (f ()).to_raise "string expected, got no value"
    - 'it diagnoses argument #1 type not string':
         stringy = setmetatable ({}, {__tostring = function () end})
         expect (f (nil)).to_raise "string expected, got nil"
         expect (f (stringy)).not_to_raise "string expected"
    - 'it diagnoses missing argument #2':
         expect (f "X").to_raise "integer expected, got no value"
    - 'it diagnoses argument #2 type not number':
         expect (f ("X", nil)).to_raise "integer expected, got nil"
         expect (f ("X", '1')).not_to_raise "integer expected"
    - 'it diagnoses argument #2 type not integer':
         expect (f ("X", 1.0001)).to_raise "number has no integer representation"
         expect (f ("X", '1.0001')).to_raise "number has no integer representation"
    - 'it diagnoses argument #4 type not number': |
         expect (f ("X", 1, "ohnoes", false)).
           to_raise "bad argument #4 to 'argerror' (integer expected, got boolean)"
    - 'it diagnoses argument #4 type not integer': |
         expect (f ("X", 99999.0, "ohnoes", 0.99999)).
           to_raise "bad argument #4 to 'argerror' (number has no integer representation)"

  - it raises an argument error: |
      expect (f ("myfunc", 1)).to_raise "bad argument #1 to 'myfunc'"
  - it supports optional extramsg argument: |
      expect (f ("another", 3, "oh noes")).
        to_raise "bad argument #3 to 'another' (oh noes)"

  - context global _DEBUG is nil:
    - before: |
        shamble = [[
          _DEBUG = nil
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
           caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"
  - context global _DEBUG is false:
    - before: |
        shamble = [[
          _DEBUG = false
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
           caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"
  - context global _DEBUG is true:
    - before: |
        shamble = [[
          _DEBUG = true
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
          caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"
  - context global _DEBUG.argcheck is nil:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = nil }
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
           caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"
  - context global _DEBUG.argcheck is false:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = false }
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
           caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"
  - context global _DEBUG.argcheck is true:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = true }
        ]] .. preamble
    - it reports correct source line with optional stack level argument: |
        expect (luaproc (shamble .. [[
          caller (2)
        ]])).to_fail_while_matching ":9: bad argument #1 to 'badfunc' %(you are an idiot%)"
        expect (luaproc (shamble .. [[
          caller (1)
        ]])).to_fail_while_matching ":7: bad argument #1 to 'badfunc' %(you are an idiot%)"
    - it suppresses position information at level 0: |
        expect (luaproc (shamble .. [[
          caller (0)
        ]])).to_fail_while_matching "^[^:]+: bad argument #1 to 'badfunc' %(you are an idiot%)"


- describe getfenv:


- describe getmetamethod:
  - before:
      f = M.getmetamethod

  - context with a table:
    - before:
        fn = function () return "uh-oh" end
        method = function () return "called" end
        functor = setmetatable ({}, {__call = method})
        t = setmetatable (
          {field = 0, fn = fn, morefn = fn},
          {field = 1, fn = functor, method = method}
        )
    - it returns nil for missing metamethods:
        expect (f (t, "morefn")).to_be (nil)
    - it returns nil for non-callable metatable entries:
        expect (f (t, "field")).to_be (nil)
    - it returns a function metamethod:
        expect (f (t, "method")).to_be (method)
        expect (f (t, "method")()).to_be "called"
    - it returns a functor metamethod:
        expect (f (t, "fn")).to_be (functor)
        expect (f (t, "fn")()).to_be "called"


- describe ipairs:
  - before: |
      __index = function (t, n)
        if n <= #t[1] then
          return string.sub (t[1], n ,n)
        end
      end
      __ipairs = function (t)
        return function (x, i)
          if i < 5 then return i + 1, x[i] end
        end, {"an", "unused", "proxy", "table"}, 0
      end
      __len = function (t) return 2 end
      src = {"foo", "bar", 5, 42}
      t = {}

      f = M.ipairs

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
         expect (f ()).to_raise "value expected"
    - 'it diagnoses nil-valued argument #1':
         expect (f (nil)).to_raise "value expected"
    - 'it diagnoses argument #1 type not table':
         expect (f (false)).to_raise "value expected"

  - it works for an empty list:
      for i, v in f {} do t[i] = v end
      expect (t).to_equal {}
  - it is an iterator over integer-keyed table values:
      for i, v in f (src) do t[i] = v end
      expect (t).to_equal (src)
  - it iterates from 1 up to element before the first nil:
      for i, v in f {1, 2, nil, nil, 5, 6} do t[i] = v end
      expect (t).to_equal {1, 2}
  - it ignores the dictionary part of a table:
      for i, v in f {"foo", 42; bar = "baz", qux = "quux"} do
        t[i] = v
      end
      expect (t).to_equal {"foo", 42}
  - it respects __index metamethod:
      for i, v in f (setmetatable ({"abc", [4]="d"}, {__index = __index})) do
        t[i] = v
      end
      expect (t).to_equal {"abc", "b", "c", "d"}
  - it ignores __ipairs metamethod:
      for i, v in f (setmetatable (src, {__ipairs = __ipairs})) do
        t[i] = v
      end
      expect (t).to_equal (src)
  - it ignores __len metamethod:
      for k, v in f (setmetatable (src, {__len = __len})) do t[k] = v end
      expect (t).to_equal (src)


- describe len:
  - before:
      __len = function (x) return 42 end

      f = M.len

  - it works for an empty list:
      src = {}
      expect (f (src)).to_be (#src)
  - it works for an empty string:
      src = ""
      expect (f (src)).to_be (#src)
  - it respects __len metamethod:
      expect (f (setmetatable ({}, {__len = __len}))).to_be (42)
  - it does not count nil valued array part elements:
      expect (f {1, 2, 3, nil, nil, 6}).to_be (3)
  - 'it defers to the # operator':
      expect (f "abc").to_be (3)


- describe opairs:
  - before:
      __index = function (t, k)
        if type(k) == "number" and k < 10 then return 1 end
      end
      __pairs = function (t)
        return next, {"a", [5] = "proxy", "table"; foo=3, bar=1, baz=2, qux=4}
      end
      src = {"foo", bar = "baz", [5] = "quux", 42}
      t = {}

      f = M.opairs

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
         expect (f ()).to_raise "value expected"
    - 'it diagnoses nil-valued argument #1':
         expect (f (nil)).to_raise "value expected"
    - 'it diagnoses argument #1 type not table':
         expect (f (false)).to_raise "value expected"

  - it works for an empty list:
      for i, v in f {} do t[i] = v end
      expect (t).to_equal {}
  - it is an iterator over all table values:
      for k, v in f (src) do t[k] = v end
      expect (t).to_equal (src)
  - it returns numeric keys in order:
      for k in f (src) do table.insert (t, k) end
      expect (t).to_equal {1, 2, 5, "bar"}
  - it returns non-numeric keys in asciibetical order:
      for k in f {foo=1, bar=2, baz=3, quux=4} do table.insert (t, k) end
      expect (t).to_equal {"bar", "baz", "foo", "quux"}
  - it respects __pairs metamethod:
      for k, v in f (setmetatable (src, {__pairs = __pairs})) do t[k] = v end
      expect (t).
        to_equal {"a", [5] = "proxy", "table", foo=3, bar=1, baz=2, qux=4}
  - it returns __pairs numeric keys in order:
      for k in f (setmetatable (src, {__pairs = __pairs})) do
        if type (k) == "number" then table.insert (t, k) end
      end
      expect (t).to_equal {1, 2, 5}
  - it returns __pairs non-numeric keys in asciibetical order:
      for k in f (setmetatable (src, {__pairs = __pairs})) do
        if type (k) ~= "number" then table.insert (t, k) end
      end
      expect (t).to_equal {"bar", "baz", "foo", "qux"}


- describe pack:
  - before:
      f = M.pack

  - it returns a table:
      expect (type (f ())).to_be "table"
  - it sets the 'n' field:
      expect (f ().n).not_to_be (nil)
      expect (f (1, 2, 3).n).to_be (3)
  - it packs arguments into the returned table:
      expect (f (1, 2, 3)).to_equal {1, 2, 3; n = 3}


- describe package:
  - it sets dirsep string:
      s = M.package.dirsep
      expect (type (s)).to_be "string"
      expect (#s).not_to_be (0)
  - it sets execdir string:
      s = M.package.execdir
      expect (type (s)).to_be "string"
      expect (#s).not_to_be (0)
  - it sets igmark string:
      s = M.package.igmark
      expect (type (s)).to_be "string"
      expect (#s).not_to_be (0)
  - it sets pathmark string:
      s = M.package.pathmark
      expect (type (s)).to_be "string"
      expect (#s).not_to_be (0)
  - it sets pathsep string:
      s = M.package.pathsep
      expect (type (s)).to_be "string"
      expect (#s).not_to_be (0)


- describe pairs:
  - before:
      __index = function (t, k)
        if type(k) == "number" and k < 10 then return 1 end
      end
      __pairs = function (t)
        return next, {"a", "proxy", "table"}
      end
      src = {"foo", bar = "baz", [5] = "qux", 42}
      t = {}

      f = M.pairs

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
         expect (f ()).to_raise "table expected, got no value"
    - 'it diagnoses nil-valued argument #1':
         expect (f (nil)).to_raise "table expected, got nil"
    - 'it diagnoses argument #1 type not table':
         expect (f (false)).to_raise "table expected, got boolean"

  - it works for an empty list:
      for i, v in f {} do t[i] = v end
      expect (t).to_equal {}
  - it is an iterator over all table values:
      for k, v in f (src) do t[k] = v end
      expect (t).to_equal (src)
  - it respects __pairs metamethod:
      for k, v in f (setmetatable (src, {__pairs = __pairs})) do t[k] = v end
      expect (t).to_equal {"a", "proxy", "table"}


- describe setfenv:


- describe str:
  - before:
      f = M.str

  - it renders primitives exactly like system tostring:
      expect (f (nil)).to_be (tostring (nil))
      expect (f (false)).to_be (tostring (false))
      expect (f (42)).to_be (tostring (42))
      expect (f (f)).to_be (tostring (f))
      expect (f "a string").to_be "a string"
  - it renders empty tables as a pair of braces:
      expect (f {}).to_be ("{}")
  - it renders table array part compactly:
      expect (f {"one", "two", "five"}).
        to_be '{one, two, five}'
  - it renders a table dictionary part compactly:
      expect (f { one = true, two = 2, three = {3}}).
        to_be '{one=true, three={3}, two=2}'
  - it renders array elements before dictionary elements:
      expect (f {7, six="five", 4, 3, one=2}).
        to_be '{7, 4, 3; one=2, six=five}'
  - it renders table keys in table.sort order:
      expect (f { one = 3, two = 5, three = 4, four = 2, five = 1 }).
        to_be '{five=1, four=2, one=3, three=4, two=5}'
  - it renders keys with invalid symbol names compactly:
      expect (f { _ = 0, word = 0, ["?"] = 1, ["a-key"] = 1, ["[]"] = 1 }).
        to_be '{?=1, []=1, _=0, a-key=1, word=0}'


- describe unpack:
  - before:
      t = {1, 2, 5}
      u = {1, 2, 5, n=3}
      f = function (...) return pack (M.unpack (...)) end

  - context with bad arguments:
    - 'it diagnoses missing argument #1':
         expect (f ()).to_raise "table expected, got no value"
    - 'it diagnoses nil-valued argument #1':
         expect (f (nil)).to_raise "table expected, got nil"
    - 'it diagnoses argument #1 type not table':
         expect (f (false)).to_raise "table expected, got boolean"
    - 'it diagnoses argument #2 type not number': |
         expect (f (t, false)).
           to_raise "bad argument #2 to 'unpack' (integer expected, got boolean)"
    - 'it diagnoses argument #2 type not integer': |
         expect (f (t, 1.5)).
           to_raise "bad argument #2 to 'unpack' (number has no integer representation)"
         expect (f (t, '1.5')).
           to_raise "bad argument #2 to 'unpack' (number has no integer representation)"
    - 'it diagnoses argument #3 type not number': |
         expect (f (t, 1, false)).
           to_raise "bad argument #3 to 'unpack' (integer expected, got boolean)"
    - 'it diagnoses argument #3 type not integer': |
         expect (f (t, 1, 1.5)).
           to_raise "bad argument #3 to 'unpack' (number has no integer representation)"
         expect (f (t, '1', '1.5')).
           to_raise "bad argument #3 to 'unpack' (number has no integer representation)"

  - it works with an empty sequence:
      expect (f {}).to_equal {n=0}
  - it returns all elements of a sequence:
      expect (f (t)).to_equal (u)
  - it stops before the first `nil` valued element:
      expect (f {1, 2, 5, nil}).to_equal (u)
      expect (f {1, 2, 5, nil, 3}).to_equal (u)
      expect (f {nil, 1, nil, 2}).to_equal {n=0}
  - it ignores non-sequence elements:
      expect (f {1, 2, 5, n=2}).to_equal (u)
      expect (f {1, foo='bar', 2, baz={4}, 5}).to_equal (u)
  - it respects optional `from_index` argument:
      expect (f (t, 1)).to_equal (u)
      expect (f (t, 2)).to_equal {2, 5, n=2}
      expect (f (t, 3)).to_equal {5, n=1}
      expect (f (t, 4)).to_equal {n=0}
      expect (f (t, 42)).to_equal {n=0}
  - it stops before first `nil` even if `from_index` is larger:
      expect (f ({[42]=1}, 42)).to_equal {n=0}
  - it returns initial `nils` when `from_index` is smaller than 1:
      expect (f ({1, 2, 5}, 0)).to_equal {nil, 1, 2, 5, n=4}
      expect (f ({1, 2, 5}, -1)).to_equal {nil, nil, 1, 2, 5, n=5}
  - it respects optional `to_index` argument:
      expect (f ({1, 2, 5}, nil, 3)).to_equal (u)
      expect (f ({1, 2, 5}, nil, 2)).to_equal {1, 2, n=2}
      expect (f ({1, 2, 5}, nil, 1)).to_equal {1, n=1}
      expect (f ({1, 2, 5}, nil, 0)).to_equal {n=0}
  - it returns additional `nils` when `to_index` is greater than sequence length:
      expect (f ({1, 2, 5}, nil, 4)).to_equal {1, 2, 5, n=4}
      expect (f ({1, 2, 5}, nil, 42)).to_equal {1, 2, 5, n=42}
  - it accepts `from_index` and `to_index` together:
      expect (f (t, 1, 3)).to_equal (u)
      expect (f (t, 0, 4)).to_equal {nil, 1, 2, 5, n=5}
      expect (f (t, 0, 2)).to_equal {nil, 1, 2, n=3}
      expect (f (t, 1, 2)).to_equal {1, 2, n=2}
      expect (f (t, 2, 3)).to_equal {2, 5, n=2}
      expect (f (t, 2, 4)).to_equal {2, 5, n=3}
  - it returns nothing if `from_index` is larger than `to_index`:
      expect (f (t, 3, 1)).to_equal {n=0}
      expect (f (t, 1, -1)).to_equal {n=0}
      expect (f (t, -1, -2)).to_equal {n=0}
  - it returns `nils` if `from_index` and `to_index` are out-of-bounds:
      expect (f (t, -1, -1)).to_equal {n=1}
      expect (f (t, -2, -1)).to_equal {n=2}
      expect (f (t, 100, 199)).to_equal {n=100}


- describe version:
  - before:
      x = M.version

  - it returns a string:
      expect (type (M.version)).to_be "string"
  - it contains package description:
      expect (string.match (M.version, "Normalized Lua Functions")).
        not_to_be (nil)
  - it ends with a semantic version number:
      expect (string.match (M.version, "([%.%d]+)%D*$")).
        not_to_be (nil)
