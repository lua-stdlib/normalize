before:
  this_module = "std.normalize._base"

  M = require (this_module)

specify std.normalize._base:
- context when required:
  - it does not touch the global table:
      expect (show_apis {added_to="_G", by=this_module}).
        to_equal {}

# TODO: fix Specl so that it doesn't mangle the environments so badly
#       that the only way to run tests that need to mess with require
#       and/or package.loaded is from a separate Lua process :(
# TODO: find a clean API for patching functions in the environment
- describe strict:
  - context with unreleased specl:
    - it does not break require:
        pending "next point release of Specl 14.1"
        package.loaded["std.strict.init"] = "MAGIC"
        expect (require "std.strict.init").to_be "MAGIC"
  - context std.strict is installed:
    - before: |
        preamble = [[
          package.loaded["std.strict.init"] = "MAGIC"
          if type (_G._DEBUG) == "table" then
            package.loaded["std.debug_init"] = {strict = _G._DEBUG.strict}
          else
            package.loaded["std.debug_init"] = {strict = _G._DEBUG}
          end
          M = require "std.normalize._base"
        ]]
    - context global _DEBUG is nil:
      - it returns std.strict implementation:
          expect (luaproc (preamble .. [[
            os.exit (M.strict == "MAGIC" and 0 or 1)
          ]])).to_succeed_with ""
    - context global _DEBUG is false:
       - it returns a pass-through environment setter:
          expect (luaproc ([[
            _DEBUG = false
            ]] .. preamble .. [[
            env = {"MAGIC"}
            print (env == M.strict (env))
            os.exit (M.strict ~= require "std.strict.init" and 0 or 1)
          ]])).to_succeed_while_matching "^true"
    - context global _DEBUG is true:
      - it returns std.strict implementation:
          expect (luaproc ([[
            _DEBUG = true
            ]] .. preamble .. [[
            os.exit (M.strict == require "std.strict.init" and 0 or 1)
          ]])).to_succeed_with ""
    - context global _DEBUG.strict is nil:
      - it returns std.strict implementation:
          expect (luaproc ([[
            _DEBUG = { strict = nil }
            ]] .. preamble .. [[
            os.exit (M.strict == require "std.strict.init" and 0 or 1)
          ]])).to_succeed_with ""
    - context global _DEBUG.strict is false:
      - it returns std.strict implementation:
          expect (luaproc ([[
            _DEBUG = { strict = false }
            ]] .. preamble .. [[
            env = {"MAGIC"}
            print (env == M.strict (env))
            os.exit (M.strict ~= require "std.strict.init" and 0 or 1)
          ]])).to_succeed_while_matching "^true"
    - context global _DEBUG.strict is true:
      - it returns std.strict implementation:
          expect (luaproc ([[
            _DEBUG = { strict = true }
            ]] .. preamble .. [[
            os.exit (M.strict == require "std.strict.init" and 0 or 1)
          ]])).to_succeed_with ""
