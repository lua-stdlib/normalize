# Many of these examples are a lot trickier than they look!
#
#  0. Specl is already doing weird things with `require` to ensure
#     that it runs in the context of the example and not in the
#     environment of the Specl implementation code, so things are
#     weird even before we touch anything here!
#  1. We need to capture (into local symbols) anything we still need
#     access to after calling `_strict`, because at that point
#     the execution environment is obliterated...
#  2. But, we can't capture `require` blindly, because some examples
#     rely on changing the global `require` used inside the `_typecheck`
#     implementation... and yet other examples call `require` after
#     calling `_strict` (and obliterating the environment).
#
# Don't be surprised if fiddling with these examples, or the code
# they exercise breaks in surprising ways at first!

before: |
  this_module = "std.normalize._typecheck"

  M = require (this_module)

specify std.normalize._typecheck:
- context when required:
  - it does not touch the global table:
      expect (show_apis {added_to="_G", by=this_module}).
        to_equal {}


- describe argscheck:
  - before: |
      preamble = [[
        argscheck = require "std.normalize._typecheck".argscheck
        function inner () return "MAGIC" end
        types = {
          woot = function () return true end,
          ohno = function (t, i) return nil, nil, type (t[i]) .. " unexpected" end,
        }
        local function exit (x) os.exit (x and 0 or 1) end
      ]]

      f = M.argscheck

  - context with bad arguments:
    - it diagnoses non-callable annotations:
        x = nil
        fn = function () end
        fntor = setmetatable ({}, {__call = fn})
        expect (f "callable" .. x).
          to_raise "attempt to annotate non-callable value with 'argscheck'"
        expect (f "callable" .. fn).
          not_to_raise "attempt to annotate non-callable value with 'argscheck'"
        expect (f "callable" .. fntor).
          not_to_raise "attempt to annotate non-callable value with 'argscheck'"

  - context global _DEBUG is nil:
    - it wraps the inner function:
        expect (luaproc (preamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          print (magic ())
          exit (magic ~= inner)
        ]])).to_succeed_with "MAGIC\n"
    - it diagnoses argument validation failures: |
        expect (luaproc (preamble .. [[
          (argscheck ("magic", types.ohno) .. inner) "fail"
        ]])).to_fail_while_matching "bad argument #1 to 'magic' %(string unexpected%)"
  - context global _DEBUG is false:
    - before: |
        shamble = [[
          _DEBUG = false
        ]] .. preamble
    - it returns a pass-through decorator:
        expect (luaproc (shamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          exit (magic == inner)
        ]])).to_succeed_with ""
  - context global _DEBUG is true:
    - before: |
        shamble = [[
          _DEBUG = true
        ]] .. preamble
    - it wraps the inner function:
        expect (luaproc (shamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          print (magic ())
          exit (magic ~= inner)
        ]])).to_succeed_with "MAGIC\n"
    - it diagnoses argument validation failures: |
        expect (luaproc (shamble .. [[
          (argscheck ("magic", types.ohno) .. inner) "fail"
        ]])).to_fail_while_matching "bad argument #1 to 'magic' %(string unexpected%)"
  - context global _DEBUG.argcheck is nil:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = nil }
        ]] .. preamble
    - it wraps the inner function:
        expect (luaproc (shamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          print (magic ())
          exit (magic ~= inner)
        ]])).to_succeed_with "MAGIC\n"
    - it diagnoses argument validation failures: |
        expect (luaproc (shamble .. [[
          (argscheck ("magic", types.ohno) .. inner) "fail"
        ]])).to_fail_while_matching "bad argument #1 to 'magic' %(string unexpected%)"
  - context global _DEBUG.argcheck is false:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = false }
        ]] .. preamble
    - it returns a pass-through decorator:
        expect (luaproc (shamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          exit (magic == inner)
        ]])).to_succeed_with ""
  - context global _DEBUG.argcheck is true:
    - before: |
        shamble = [[
          _DEBUG = { argcheck = true }
        ]] .. preamble
    - it wraps the inner function:
        expect (luaproc (shamble .. [[
          magic = argscheck ("magic", types.woot) .. inner
          print (magic ())
          exit (magic ~= inner)
        ]])).to_succeed_with "MAGIC\n"
    - it diagnoses argument validation failures: |
        expect (luaproc (shamble .. [[
          (argscheck ("magic", types.ohno) .. inner) "fail"
        ]])).to_fail_while_matching "bad argument #1 to 'magic' %(string unexpected%)"


- describe types:
  - before:
      function pack (...)
        return {n = select ("#", ...), ...}
      end

      wrap = function (fn, n)
        n = n or 1
        return function (...)
          local r = pack (fn (pack (...), n))
          if r.n == 1 then
            return r[1]
          end
          return {r[1], r[2], r[3]}
        end
      end

      T = M.types

  - context accept:
    - before:
        f = wrap (T.accept)
    - it accepts a missing value:
        expect (f ()).to_be (true)
    - it accepts a nil value:
        expect (f (nil)).to_be (true)
    - it accepts anything else:
        expect (f (false)).to_be (true)
        expect (f ("1")).to_be (true)
        expect (f (f)).to_be (true)
        expect (f {f=f}).to_be (true)

  - context arg:
    - before:
        f = wrap (T.arg)
    - it rejects a missing value:
        expect (f ()).to_equal {nil, nil, "value expected"}
    - it accepts a nil value:
        expect (f (nil)).to_be (true)
    - it accepts anything else:
        expect (f (false)).to_be (true)
        expect (f ("1")).to_be (true)
        expect (f (f)).to_be (true)
        expect (f {f=f}).to_be (true)

  - context boolean:
    - before:
        x = "boolean"
        f = wrap (T[x])
    - it accepts a boolean value:
        expect (f (false)).to_be (true)
        expect (f (true)).to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-boolean values:
        expect (f {}).to_equal {nil, x, "got table"}

  - context callable:
    - before:
        x = "callable"
        f = wrap (T[x])
    - it accepts a callable value:
        expect (f (f)).to_be (true)
        expect (f (setmetatable ({}, {__call=f}))).to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-callable values:
        expect (f (false)).to_equal {nil, x, "got boolean"}

  - context function:
    - before:
        x = "function"
        f = wrap (T[x])
    - it accepts a function value:
        expect (f (f)).to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-function values:
        expect (f (false)).to_equal {nil, x, "got boolean"}
        expect (f (setmetatable ({}, {__call=f}))).
          to_equal {nil, x, "got table"}

  - context integer:
    - before:
        x = "integer"
        f = wrap (T[x])
    - it accepts an integer-like value:
        expect (f (1234)).to_be (true)
        expect (f "1234").to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-integer-like numbers:
        expect (f "123.000001").
          to_equal {nil, nil, "number has no integer representation"}
        expect (f (math.pi)).
          to_equal {nil, nil, "number has no integer representation"}
    - it rejects non-integer values:
        expect (f (false)).to_equal {nil, x, "got boolean"}

  - context missing:
    - before:
        f = wrap (T.missing)
    - it accepts a missing value:
        expect (f ()).to_be (true)
    - it rejects a nil value:
        expect (f (nil)).to_equal {nil, ""}
    - it rejects anything else:
        expect (f (false)).to_equal {nil, ""}
        expect (f ("1")).to_equal {nil, ""}
        expect (f (f)).to_equal {nil, ""}
        expect (f {f=f}).to_equal {nil, ""}

  - context nil:
    - before:
        x = "nil"
        f = wrap (T[x])
    - it accepts a nil value:
        expect (f (nil)).to_be (true)
    - it accepts a missing value:
        expect (f ()).to_be (true)
    - it rejects non-nil values:
        expect (f (false)).to_equal {nil, x, "got boolean"}

  - context number:
    - before:
        x = "number"
        f = wrap (T[x])
    - it accepts a numeric value:
        expect (f (1234)).to_be (true)
        expect (f (1234.567)).to_be (true)
        expect (f (12e-34)).to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-number-like values:
        expect (f (false)).to_equal {nil, x, "got boolean"}
        expect (f "1234").to_equal {nil, x, "got string"}
        expect (f "1234.567").to_equal {nil, x, "got string"}

  - context string:
    - before:
        x = "string"
        f = wrap (T[x])
    - it accepts a string value:
        expect (f "").to_be (true)
        expect (f "a string").to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-string values:
        stringy = function () return "stringy" end
        expect (f (false)).to_equal {nil, x, "got boolean"}
        expect (f (setmetatable ({}, {__tostring = stringy}))).
          to_equal {nil, x, "got table"}

  - context stringy:
    - before:
        x = "string"
        f = wrap (T.stringy)
    - it accepts a string-like value:
        stringy = function () return "stringy" end
        expect (f "").to_be (true)
        expect (f "a string").to_be (true)
        expect (f (setmetatable ({}, {__tostring = stringy}))).
          to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-string-like values:
        expect (f (false)).to_equal {nil, x, "got boolean"}
        expect (f (setmetatable ({}, {__tostring = "stringy"}))).
          to_equal {nil, x, "got table"}

  - context table:
    - before:
        x = "table"
        f = wrap (T[x])
    - it accepts a table value:
        expect (f {}).to_be (true)
        expect (f (pack (1, 2, 3))).to_be (true)
    - it rejects missing value:
        expect (f ()).to_equal {nil, x, "got no value"}
    - it rejects nil value:
        expect (f (nil)).to_equal {nil, x, "got nil"}
    - it rejects non-table values:
        expect (f (false)).to_equal {nil, x, "got boolean"}

  - context value:
    - before:
        f = wrap (T.value)
    - it rejects a missing value:
        expect (f ()).to_equal {nil, "value"}
    - it rejects a nil value:
        expect (f (nil)).to_equal {nil, "value"}
    - it accepts anything else:
        expect (f (false)).to_be (true)
        expect (f ("1")).to_be (true)
        expect (f (f)).to_be (true)
        expect (f {f=f}).to_be (true)
